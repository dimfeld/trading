{"version":3,"sources":["../src/position_info.ts"],"names":["positionInfo","position","fetchQuote","openTotalBasis","maxTotalBasis","legData","trades","forEach","trade","legs","leg","thisLong","size","data","symbol","openingIsLong","openLegs","maxLegs","totalBasis","openBasis","realized","multiplier","length","value","price","theseLegsBasis","Math","abs","underlyingPrice","currentLegValues","map","legPrice","NaN","openValue","reduce","acc","val","totalRealized","Object","values","unrealized","openPlPct","totalPlPct","netLiquidity"],"mappings":"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","sourcesContent":["import { Position, Trade, PositionLegInfo } from './types';\n\nexport default function positionInfo<T extends Position<TR>, TR extends Trade>(\n  position: T,\n  fetchQuote: (symbol: string) => number | null\n) {\n  let openTotalBasis = 0;\n  let maxTotalBasis = 0;\n\n  let legData: { [key: string]: PositionLegInfo } = {};\n\n  position.trades.forEach((trade) => {\n    trade.legs.forEach((leg) => {\n      let thisLong = leg.size > 0;\n      let data = legData[leg.symbol];\n      if (!data) {\n        data = legData[leg.symbol] = {\n          openingIsLong: thisLong,\n          openLegs: 0,\n          maxLegs: 0,\n          totalBasis: 0,\n          openBasis: 0,\n          realized: 0,\n          multiplier: leg.symbol.length > 6 ? 100 : 1,\n        };\n      }\n\n      let value = leg.size * leg.price * data.multiplier;\n\n      // If this leg was opened in the same direction as the\n      // original leg (or it's the first) then add it to the basis.\n      if (thisLong === data.openingIsLong) {\n        data.maxLegs += leg.size;\n        data.openBasis += value;\n        openTotalBasis += value;\n      } else {\n        let theseLegsBasis =\n          data.openBasis * Math.abs(leg.size / data.openLegs);\n        data.openBasis -= theseLegsBasis;\n        openTotalBasis -= theseLegsBasis;\n\n        let realized = -1 * (value + theseLegsBasis);\n        data.realized += realized;\n      }\n\n      if (Math.abs(data.openBasis) > Math.abs(data.totalBasis)) {\n        data.totalBasis = data.openBasis;\n      }\n\n      data.openLegs += leg.size;\n    });\n\n    if (Math.abs(openTotalBasis) > Math.abs(maxTotalBasis)) {\n      maxTotalBasis = openTotalBasis;\n    }\n  });\n\n  let underlyingPrice = fetchQuote(position.symbol);\n  let currentLegValues = position.legs.map((leg) => {\n    let legPrice = fetchQuote(leg.symbol);\n    if (!legPrice) {\n      return NaN;\n    }\n\n    let multiplier = leg.symbol.length > 6 ? 100 : 1;\n    return leg.size * legPrice * multiplier;\n  });\n\n  let openValue = currentLegValues.reduce((acc, val) => acc + val, 0);\n\n  let totalRealized = Object.values(legData).reduce(\n    (acc, leg) => acc + leg.realized,\n    0\n  );\n\n  let unrealized = openValue - openTotalBasis;\n  let openPlPct =\n    openTotalBasis === 0 ? 0 : (100 * unrealized) / Math.abs(openTotalBasis);\n  let totalPlPct =\n    (100 * (unrealized + totalRealized)) / Math.abs(maxTotalBasis);\n\n  return {\n    underlyingPrice,\n\n    totalPlPct,\n    totalRealized,\n    totalBasis: maxTotalBasis,\n\n    openPlPct,\n    unrealized,\n    openBasis: openTotalBasis,\n\n    netLiquidity: openValue,\n\n    legData,\n  };\n}\n"],"file":"position_info.js"}