{"version":3,"sources":["../src/leg_finder.ts"],"names":["each","isEmpty","pick","sortedIndexBy","sorter","debugMod","debug","closestDeltas","strikes","deltas","sorted","Object","values","map","contractList","sort","x","Math","abs","delta","length","closest","targetDelta","index","greaterDistance","Infinity","lesserDistance","best","target","contract","contracts","filter","Boolean","closestAfterDte","dates","dteTarget","closestDte","dteNum","Number","parseInt","requireMonthly","dte","expiration","difference","strikeMap","key","expirationDate","dteStr","split","isMonthly","desc","description","endsWith","d","analyzeSide","config","allExpirations","expirations","result","filterLiquidity","data","spreadPercent","maxSpreadPercent","totalVolume","minVolume","openInterest","minOpenInterest","analyzeLiquidity","chain","calls","callExpDateMap","puts","putExpDateMap","allData","concat","results","flatMap","targetDte","bid","ask","symbol"],"mappings":"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","sourcesContent":["import each from 'lodash/each';\nimport isEmpty from 'just-is-empty';\nimport pick from 'just-pick';\nimport sortedIndexBy from 'lodash/sortedIndexBy';\nimport sorter from 'sorters';\nimport debugMod from 'debug';\nimport { ContractInfo } from 'types';\n\nconst debug = debugMod('option_finder');\n\nexport type StrikeMap = { [key: string]: ContractInfo[] };\nexport type ExpirationDateMap = { [key: string]: StrikeMap };\n\nexport function closestDeltas(strikes: StrikeMap, deltas: number[]) {\n  let sorted = Object.values(strikes)\n    .map((contractList) => contractList[0])\n    .sort(\n      sorter<ContractInfo>((x) => Math.abs(x.delta))\n    );\n\n  if (!sorted.length) {\n    return null;\n  }\n\n  let closest = deltas.map((targetDelta) => {\n    if (targetDelta > 1) {\n      // Deal with 0-1 delta range.\n      targetDelta /= 100;\n    }\n    let index = sortedIndexBy<Partial<ContractInfo>>(\n      sorted,\n      { delta: targetDelta },\n      (x) => Math.abs(x.delta)\n    );\n    let greaterDistance =\n      index < sorted.length\n        ? Math.abs(sorted[index].delta) - targetDelta\n        : Infinity;\n    let lesserDistance =\n      index > 0 ? targetDelta - Math.abs(sorted[index - 1].delta) : Infinity;\n    let best =\n      greaterDistance < lesserDistance ? sorted[index] : sorted[index - 1];\n\n    return {\n      target: targetDelta,\n      contract: best,\n      contracts: [sorted[index - 1], sorted[index]].filter(Boolean),\n    };\n  });\n\n  return closest;\n}\n\ninterface ClosestDte {\n  target: number;\n  dte: number;\n  expiration: string;\n  difference: number;\n  strikes: StrikeMap;\n}\n\nexport function closestAfterDte(\n  dates: ExpirationDateMap,\n  dteTarget: string[]\n): ClosestDte[] {\n  let closestDte = dteTarget.map((target) => {\n    let dteNum = Number.parseInt(target, 10);\n    let requireMonthly = target[target.length - 1] === 'M';\n    return {\n      target: dteNum,\n      dte: null,\n      expiration: null,\n      difference: Infinity,\n      strikes: null,\n      requireMonthly,\n    };\n  });\n\n  debug(closestDte);\n\n  each(dates, (strikeMap, key) => {\n    let [expirationDate, dteStr] = key.split(':');\n    let dte = +dteStr;\n    let isMonthly = false;\n    each(strikeMap, (contract) => {\n      let desc = contract[0].description || '';\n      isMonthly = !desc.endsWith('(Weekly)');\n      return false;\n    });\n\n    each(closestDte, (d) => {\n      if (d.requireMonthly && !isMonthly) {\n        return;\n      }\n\n      let difference = dte - d.target;\n\n      // If the current expiration >= the target number and is smaller than what we had before, then use it.\n      if (difference >= 0 && difference < d.difference) {\n        d.strikes = strikeMap;\n        d.difference = difference;\n        d.dte = dte;\n        d.expiration = expirationDate;\n      }\n    });\n  });\n\n  return closestDte;\n}\n\nexport interface AnalyzeSideOptions {\n  dte: string[];\n  delta: number[];\n}\n\nexport function analyzeSide(\n  config: AnalyzeSideOptions,\n  allExpirations: ExpirationDateMap\n) {\n  if (isEmpty(allExpirations)) {\n    return [];\n  }\n\n  let expirations = closestAfterDte(allExpirations, config.dte);\n  let result = expirations.map((expiration) => {\n    let deltas = closestDeltas(expiration.strikes, config.delta);\n    return {\n      deltas,\n      ...expiration,\n    };\n  });\n\n  return result;\n}\n\nexport interface FilterLiquidityArguments {\n  maxSpreadPercent?: number;\n  minVolume?: number;\n  minOpenInterest?: number;\n}\n\nexport interface LiquidityInfo {\n  spreadPercent?: number;\n  totalVolume?: number;\n  openInterest?: number;\n}\n\nexport function filterLiquidity(\n  config: FilterLiquidityArguments,\n  data: LiquidityInfo\n) {\n  if (data.spreadPercent > (config.maxSpreadPercent || Infinity)) {\n    return false;\n  }\n\n  if (data.totalVolume < (config.minVolume || 0)) {\n    return false;\n  }\n\n  if (data.openInterest < (config.minOpenInterest || 0)) {\n    return false;\n  }\n\n  return true;\n}\n\nexport interface AnalyzeLiquidityOptions {\n  symbol: string;\n  callExpDateMap: ExpirationDateMap;\n  putExpDateMap: ExpirationDateMap;\n}\n\nexport function analyzeLiquidity(\n  config: AnalyzeSideOptions & FilterLiquidityArguments,\n  chain: AnalyzeLiquidityOptions\n) {\n  // debug(\"Analyzing\", chain, typeof chain, \"array\", isArray(chain));\n  let calls = analyzeSide(config, chain.callExpDateMap);\n  let puts = analyzeSide(config, chain.putExpDateMap);\n\n  let allData = calls.concat(puts);\n  let results = allData.flatMap((expiration) => {\n    return expiration.deltas\n      .map((delta) => {\n        let contract = delta.contract;\n        return {\n          expiration: expiration.expiration,\n          targetDte: expiration.target,\n          targetDelta: delta.target,\n          spreadPercent: contract.bid\n            ? (contract.ask / contract.bid - 1) * 100\n            : 1000,\n          ...pick(contract, [\n            'symbol',\n            'delta',\n            'putCall',\n            'strikePrice',\n            'daysToExpiration',\n            'bid',\n            'ask',\n            'totalVolume',\n            'openInterest',\n          ]),\n        };\n      })\n      .filter((data) => filterLiquidity(config, data));\n  });\n\n  debug('Results', chain.symbol, results);\n\n  return { symbol: chain.symbol, results };\n}\n"],"file":"leg_finder.js"}